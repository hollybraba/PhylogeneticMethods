---
title: "Final Project"
output:
  html_document:
    df_print: paged
---

Using diversitree packages...
```{r}
library("diversitree")
library("phytools")
library("ape")
library("phangorn")
library("tidyverse")
```

Use phylogeny and trait data from homework 8 to make and test the model.
I want to have all possible trait combinations, so I made everything in the Hylobates genera have 1 for T1 (warning: made-up data!)
```{r, cache = TRUE}
require("corHMM")
require(phytools)
data(primates)
primates$trait[which(grepl("Hylobates", primates$trait[,1])),2] <- 1
```

Tree isn't bifurcating, use multi2di to make the tree bifurcating.
```{r}
primates$tree <- multi2di(primates$tree)
```

```{r, cache = TRUE}
# trait1 = dormancy absent (0) / dormancy present (1)
trait1 <- primates$trait[,2]
names(trait1) <- primates$trait[,1]
primates$tree <- nnls.tree(cophenetic(primates$tree), 
                           primates$tree, 
                           rooted=TRUE,
                           trace=0)
plotSimmap(make.simmap(primates$tree, trait1), 
           pts = FALSE, 
           fsize = 0.8)
```
```{r}
# trait2 = competition absent (0) / competition present (1)
trait2 <- primates$trait[,3]
names(trait2) <- primates$trait[,1]
plotSimmap(make.simmap(primates$tree, trait2), 
           pts = FALSE, 
           fsize = 0.8)
```

Make a BiSSE function using make.bisse. Use this function to test all the different hypotheses of speciation, extinction, and transition rates.
```{r}
bis <- make.bisse(tree = primates$tree,
                  states = trait1,
                  sampling.f = c(1,1))
```
bis() is now a function. Needs parameters lambda0, lambda1, mu0, mu1, q01, q10.

SpN = lambda0 =  # speciation rate, no dormancy
SpD = lambda1 =  # speciation rate, dormancy (/p)
ExN = mu0 =      # extinction rate, no dormancy
ExD = mu1 =      # extinction rate, dormancy (/p)
TrN = q01 =      # transition rate, no -> dormancy
TrD = q10 =      # transition rate, dormancy -> no
p   =            # escape rate

The results are in log-likelihood, so use exp() to make comparisons easier. The most positive likelihood is best.
For example: exp(bis(c(1,2,3,1,2,3)))

```{r}
startparambisse <- starting.point.bisse(tree = primates$tree)
```
   lambda0    lambda1        mu0        mu1        q01        q10 
0.06882283 0.06882283 0.00000000 0.00000000 0.01376457 0.01376457 
```{r}
bis_fit <- find.mle(bis, startparambisse)
bis_fit
```


Optimize the likelihoods:
```{r}
 dormancy_lik <- function(param, bisse_fn) {
 lambda0 <- params['popsize0+4
 mu0 <- params['extinction_dormrancy + 0.15 * params['extinction_nndormand
 q01 <- params['dormancy_escape_rate / params['N
 return(-bisse_fn(c(lambda0,..)))
}
 fit_model <- function(bisse_fn) {
 starting_guesses <- c(3, 1, 2)
 return(optim(starting_guesses, dormancy_lik, bisse_fn=bisse_fn))
}
```

SpN = lambda0 =  # speciation rate, no dormancy
SpD = lambda1 =  # speciation rate, dormancy (/p)
ExN = mu0 =      # extinction rate, no dormancy
ExD = mu1 =      # extinction rate, dormancy (/p)
TrN = q01 =      # transition rate, no -> dormancy
TrD = q10 =      # transition rate, dormancy -> no
p   =            # escape rate

Now that BiSSE is working, I want to run MuSSE with multiple states (dormancy-0,1, and competition-A,B)

Need to first make a trait that has 0-3 representing 0A, 1A, 0B, 1B.
```{r}
primates$trait <- primates$trait %>% mutate(T3 = case_when(T1 == 0 & T2 == 0 ~ "1",
                                                           T1 == 1 & T2 == 0 ~ "2",
                                                           T1 == 0 & T2 == 1 ~ "3",
                                                           T1 == 1 & T2 == 1 ~ "4")) %>%
   mutate_at(.vars = vars(T3), .funs = as.numeric) 

trait3 <- primates$trait[,4]
names(trait3) <- primates$trait[,1]
# 1   2   3   4
# 0A, 1A, 0B, 1B
```

```{r}
musse_fn <- make.musse(tree = primates$tree,
            states = trait3,
            k = 4,
            sampling.f = c(1,1,1,1)
            )
```

```{r}
startingparammusse <- starting.point.musse(tree = primates$tree, k = 4)
```

```{r}
musse_fit <- find.mle(musse_fn, startingparammusse)
musse_fit
```


```{r}
musse_fit$par
```



Make a function that estimates and optimizes the parameters to the best likelihood.
```{r}
estimator <- function(params, musse_fn, BADVAL=1e6, return_negloglike=TRUE) {
   if(!return_negloglike) {
      BADVAL <- -1 * BADVAL
   }
   p <- params['p']
   if(p<1) {
      return(BADVAL)
   }
   lambda1 <- params['lambda1']
   lambda2 <- params['lambda2']
   lambda3 <- params['lambda3']
   lambda4 <- params['lambda4']
   if(lambda2>lambda1) {
      return(BADVAL)
   }
   if(lambda4>lambda3) {
      return(BADVAL)
   }   
   mu1 <- params['mu1']
   mu2 <- mu1/p
   mu3 <- params['mu3']
   mu4 <- mu3/p
   q12 <- params['q12']
   q13 <- params['q13']
   q14 <- 0
   q21 <- params['q21']
   q23 <- params['q23']
   q24 <- params['q24']
   q31 <- params['q31']
   q32 <- params['q32']
   q34 <- params['q34']
   q41 <- 0
   q42 <- params['q42']
   q43 <- params['q43']
   
   arguments <- c(lambda1,lambda2,lambda3,lambda4,mu1,mu2,mu3,mu4,q12,q13,q14,q21,q23,q24,q31,q32,q34,q41,q42,q43)
   if(any(arguments<0)) {
      return(BADVAL)
   }
   results <- ifelse(return_negloglike, 1, -1)*musse_fn(arguments) # negative log likelihood, so smaller is better
   print(c(arguments, results))
   results
}
```

Starting parameters for optimization.
```{r}
params_start <- c(p=1, 
                  lambda1=0.1, 
                  lambda2=0.1, 
                  lambda3=0.1, 
                  lambda4=0.1,
                  mu1=0.05, 
                  mu3=0.05, 
                  q12=0.001, 
                  q13=0.001, 
                  q21=0.001, 
                  q23=0.001, 
                  q24=0.001, 
                  q31=0.001, 
                  q32=0.001, 
                  q34=0.001, 
                  q42=0.001, 
                  q43=0.001)
```

Use the starting parameters in optim() to find the best parameters.
```{r}
best_fit <- optim(par=params_start, fn=estimator, musse_fn=musse_fn)
best_fit
```



Use MCMC to find the distribution of likelihoods. Use the optimized parameters to hopefully start in a better place.
Start by making the output file.
```{r}
file.create("/Users/hollybrabazon/Documents/PhD_UTK_EPP/Course_work/EEB587_PhylogeneticMethods/PhylogeneticMethods/Final_Project/MCMC_output_p>1.csv")
```

Then use mcmc().
```{r}
mcmc_resuts <- diversitree::mcmc(lik = estimator, 
                                 x.init = best_fit$par, 
                                 nsteps = 100, 
                                 w = 1, 
                                 musse_fn = musse_fn, 
                                 return_negloglike = FALSE,
                                 print.every = 100,
                                 save.file = "/Users/hollybrabazon/Documents/PhD_UTK_EPP/Course_work/EEB587_PhylogeneticMethods/PhylogeneticMethods/Final_Project/MCMC_output_p>1.csv",
                                 save.every = 1)
```


















Make a function that creates all 20 parameters as random numbers based on dormancy rules.
```{r}
generator <- function(p, musse_fn) {
   lambda1 <- runif(1, min = 0, max = .1)
   lambda2 <- runif(1, min = 0, max = lambda1)
   lambda3 <- runif(1, min = 0, max = .1)
   lambda4 <- runif(1, min = 0, max = lambda3)
   mu1 <- runif(1, min = 0, max = .1)
   mu2 <- mu1/p
   mu3 <- runif(1, min = 0, max = .1)
   mu4 <- mu3/p
   q12 <- runif(1, min = 0, max = .1)
   q13 <- runif(1, min = 0, max = .1)
   q14 <- 0
   q21 <- runif(1, min = 0, max = .1)
   q23 <- runif(1, min = 0, max = .1)
   q24 <- runif(1, min = 0, max = .1)
   q31 <- runif(1, min = 0, max = .1)
   q32 <- runif(1, min = 0, max = .1)
   q34 <- runif(1, min = 0, max = .1)
   q41 <- 0
   q42 <- runif(1, min = 0, max = .1)
   q43 <- runif(1, min = 0, max = .1)
   
   arguments <- c(lambda1,lambda2,lambda3,lambda4,mu1,mu2,mu3,mu4,q12,q13,q14,q21,q23,q24,q31,q32,q34,q41,q42,q43)
   results <- musse_fn(arguments)
   output <- data.frame(p=p,
                        lambda1=lambda1,
                        lambda2=lambda2,
                        lambda3=lambda3,
                        lambda4=lambda4,
                        mu1=mu1,
                        mu2=mu2,
                        mu3=mu3,
                        mu4=mu4,
                        q12=q12,
                        q13=q13,
                        q14=q14,
                        q21=q21,
                        q23=q23,
                        q24=q24,
                        q31=q31,
                        q32=q32,
                        q34=q34,
                        q41=q41,
                        q42=q42,
                        q43=q43,
                        log_likelihood = results)
   output
}
```

Run the above function multiple times.
```{r}
test1 <- generator(p = 5, musse_fn = musse_fn) 
# rep(p, repetitions)
res <- map_dfr(.x = rep(seq(from = 1, to = 10, by = 0.2), 10), .f = ~generator(p = .x, musse_fn = musse_fn))

```

Plot p (escape rate) vs. log.likelihood.
```{r}
# plot(res$p, res$log_likelihood)

ggplot(res, aes(x = p, 
                y = log_likelihood,
                color = p)) +
   geom_point(alpha = 0.2)
```





